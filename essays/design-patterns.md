---
layout: essay
type: essay
title: "Keep Trying Until it Works"
# All dates must be YYYY-MM-DD format!
date: 2023-11-29
published: true
labels:
  - Software Engineering
---
    
<img width="350px" class="rounded float-start pe-4" src="../img/design-patterns/brute-force.jpg">

## Design Patterns is Everywhere

Think of something, a task that you do every day. Let us take your daily routine as an example, the simplest and most basic morning routine of waking up, brushing your teeth, and eating breakfast. Well, that generic routine of getting ready for the day is a perfect example of a design pattern. This repetitive task that is always done every day over and over, is a design pattern that many have become accustomed to and rely on to get through their daily life.

With that being said, design patterns aren’t always related from a software perspective, as you can see, it is simply a process that can be repeated over and over on a simple/common problem. A go-to problem-solving tool that can basically either entirely solve the problem or at least help you guide towards a better solution. One of the more common and used design patterns that you are most likely familiar with is the good old method of turning something off and on. Your device seems to be bugging out, try turning it off and on. Is your internet too slow? Have you tried turning your router off and on? It is a simple design pattern that everyone suggests whenever they run into problems.

## Brute Force the Solution

Even though this method of turning something off and on is a helpful solution, it doesn’t really apply well when it comes to software development. Thus, I rely on a different brute force design pattern which is to keep trying until it works or keep going until you understand how it works. If I find myself in a stuck situation when it comes to code that I don’t understand how it works, I find it easier to just break the code into parts. Then I try to solve those parts individually, working at it until it works. Eventually, all the different parts and components that make up the code should work and the only issue now is seeing if these parts work together.

This repetitive process of brute forcing a solution by committing trial and error does have its pros and cons. The pros are that you’ll eventually get to your solution like it or not, however, the con is that you are sacrificing a lot of time, in that time will always vary with each problem. It has a similar feeling to ramming your head into a wall until that said wall breaks, but I genuinely find that this method helps me understand problems better. It helps me see what solutions work and don't work, and from there I draw up conclusions seeing if those solutions keep on working until I meet my goal.

Although this process doesn’t sometimes apply to the real world, when it comes to real-life jobs and tasks, it often requires a lot of money and time. You will always be limited to the resources available to you and you can’t afford to keep wasting those resources for small progression. You can’t just keep building 10 different housing plans to see which house stays intact. That's why I find it helpful that I'm now learning how to solve problems that I still don’t understand because eventually, I will find a solution that will work in any future problem. Thus, my advice for problems that make you feel stuck is to always remember to use everything you have to understand the problem. It doesn’t have to be the answer right away, it's always best that you understand how you found a solution rather than finding a solution that you had no idea how you got to.
